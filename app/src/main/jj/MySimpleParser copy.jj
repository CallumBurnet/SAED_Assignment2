PARSER_BEGIN(MySimpleParser)
package org.example;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;

public class MySimpleParser {
    Map<String, ArrayList<int[]>> obstacleMap = new HashMap();
    public static void main(String[] args) throws ParseException {
        MySimpleParser parser = new MySimpleParser(System.in);
        parser.parseGameConfig();
        System.out.println("Parsed successfully.");
    }
}

PARSER_END(MySimpleParser)

// Skip spaces, newlines, and carriage returns
SKIP: { " " | "\n" | "\r" }

// Tokens for the new keywords and parentheses
TOKEN: {
    < SIZE: "size" > |
    < START: "start" > |
    < GOAL: "goal" > |
    < OBSTACLE: "obstacle" > |
    < ITEM: "item" > |
    < PLUGIN: "plugin" > |
    < SCRIPT: "script" > |
    < REQUIRES: "requires" > |
    < MESSAGE: "message" > |
    < STRING_LITERAL: "\"" (~["\""])* "\"" > |
    < EXCLAMATION: "!" > |
    < BRACE_OPEN: "{" > |
    < BRACE_CLOSE: "}" > |
    < LPAREN: "(" > |
    < RPAREN: ")" > |
    < COMMA: "," > |
    <PLUGIN_NAME: (["a"-"z", "A"-"Z"])+ ("." (["a"-"z", "A"-"Z"])+)*>|
    < SCRIPT_CONTENT : "{" (~["}"])* "}" >|

    < NUMBER: (["0"-"9"])+ >
    
}

// Method to parse the full configuration
void parseGameConfig() :
{}
{
    (sizeConfig() | startConfig() | goalConfig() | obstacleConfig() | itemConfig() | pluginConfig() | scriptConfig())* <EOF>
}


// Method to parse size (width, height)
int[] sizeConfig() :
{
    Token width, height;
}
{
    <SIZE> <LPAREN> width=<NUMBER> <COMMA> height=<NUMBER> <RPAREN>
    {
        int parsedWidth = Integer.parseInt(width.image);
        int parsedHeight = Integer.parseInt(height.image);
        System.out.println("Parsed size: (" + parsedWidth + ", " + parsedHeight + ")");
        return new int[]{parsedWidth, parsedHeight}; // Return an array with width and height
    }
}

// Method to parse start (x, y)
int[] startConfig() :
{
    Token x, y;
}
{
    <START> <LPAREN> x=<NUMBER> <COMMA> y=<NUMBER> <RPAREN>
    {
        int startX = Integer.parseInt(x.image);
        int startY = Integer.parseInt(y.image);
        System.out.println("Parsed start: (" + startX + ", " + startY + ")");
        return new int[]{startX, startY}; // Return an array with x and y
    }
}

// Method to parse goal (x, y)
int[] goalConfig() :
{
    Token x, y;
}
{
    try {

    <GOAL> <LPAREN> x=<NUMBER> <COMMA> y=<NUMBER> <RPAREN>
    {
        int goalX = Integer.parseInt(x.image);
        int goalY = Integer.parseInt(y.image);
        System.out.println("Parsed goal: (" + goalX + ", " + goalY + ")");
        return new int[]{goalX, goalY}; // Return an array with x and y
    }
    }catch(ParseException e){
            System.out.println("UU");
            return null;
    }
}

// Method to parse obstacles
Map<String, ArrayList<int[]>> obstacleConfig() :
{
    Token x, y, requires;
    ArrayList<int[]> coords = new ArrayList();
    Map<String, ArrayList<int[]>> obstacleMap = new HashMap();

}
{
    try {
    <OBSTACLE> <BRACE_OPEN> "at" <LPAREN> x=<NUMBER> <COMMA> y=<NUMBER> <RPAREN> 
    {
        System.out.println("Parsed obstacle at (" + x.image + ", " + y.image + ")");
        coords.add(new int[]{Integer.parseInt(x.image), Integer.parseInt(y.image)});
    }
    ("," <LPAREN> x=<NUMBER> <COMMA> y=<NUMBER> <RPAREN> 
    {
        System.out.println("Parsed additional obstacle at (" + x.image + ", " + y.image + ")");
        coords.add(new int[]{Integer.parseInt(x.image), Integer.parseInt(y.image)});

    })*
     <REQUIRES> requires=<STRING_LITERAL> <BRACE_CLOSE>
    {
        obstacleMap.put(requires.image, coords);
        System.out.println("Requires: " + requires.image);
        return obstacleMap;  // Return the map with obstacles and their coordinates

    }
    }catch(ParseException e){
        System.out.println("L");
        return null;
    }
}


Map<String, ArrayList<Item>> itemConfig() :
{
    Token itemName, x, y, message;
    ArrayList<Item> items = new ArrayList();
    Map<String, ArrayList<Item>> itemMap = new HashMap();
}
{
    try{
    // Ensure at least one ITEM block is present
    ( 
        <ITEM> itemName=<STRING_LITERAL> 
        <BRACE_OPEN> 
        "at" <LPAREN> x=<NUMBER> <COMMA> y=<NUMBER> <RPAREN>
        {
            items.add(new Item(itemName.image, Integer.parseInt(x.image), Integer.parseInt(y.image), null));
        }
        ("," <LPAREN> x=<NUMBER> <COMMA> y=<NUMBER> <RPAREN>
        {
            items.add(new Item(itemName.image, Integer.parseInt(x.image), Integer.parseInt(y.image), null));
        })* 
        <MESSAGE> message=<STRING_LITERAL> 
        <BRACE_CLOSE>
        {
            itemMap.put(message.image, items);
        }
    )+
    {
        return itemMap; // Return the constructed itemMap
    }
    }catch(ParseException e){
        return null;
    }
}




// Method to parse plugins
String pluginConfig() :
{
    Token pluginName;
}
{
    try {
        <PLUGIN> pluginName=<PLUGIN_NAME>
        {
            String parsedPlugin = pluginName.image; // Store the parsed plugin name
            System.out.println("Parsed plugin: " + parsedPlugin);
            return parsedPlugin; // Return the parsed plugin name
        }
    } catch (ParseException e) {
        System.out.println("Error parsing plugin: " + e.getMessage());
        return null;
    }
}



// Method to parse scripts
String scriptConfig() :
{
    Token scriptContent;
}
{
    try {
        <SCRIPT> <EXCLAMATION> scriptContent=<SCRIPT_CONTENT> // Capture everything inside the braces
        {
            String fullScriptContent = scriptContent.image;
            
            // Remove the leading and trailing braces if needed
            fullScriptContent = fullScriptContent.substring(1, fullScriptContent.length() - 1).trim();

            System.out.println("Parsed script: " + fullScriptContent);
            return fullScriptContent; // Return the entire script content
        }
    } catch (ParseException e) {
        System.out.println("Error parsing script: " + e.getMessage());
        return null;
    }
}





